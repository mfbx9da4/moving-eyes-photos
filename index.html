<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Basics -->
    <meta name="theme-color" content="#ffffff" />
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta
      name="google-site-verification"
      content="vRGNTcXZTAhXYcJLgDPMgGAOuUttLlxPIMdt5rhZfjw"
    />

    <!-- Favicon -->
    <link
      rel="apple-touch-icon"
      sizes="180x180"
      href="/static/favicon/apple-touch-icon.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href="/static/favicon/favicon-32x32.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="16x16"
      href="/static/favicon/favicon-16x16.png"
    />
    <link rel="manifest" href="/static/favicon/site.webmanifest" />

    <!-- SEO / Open Graph -->
    <title>David Alberto Adler</title>
    <meta
      name="Description"
      content="Experienced Full Stack Engineer, Founder and Contractor with a demonstrated history of working with startups and large enterprises. A blend of business and technical skills. Experience in leadership roles. Strongly attuned to business goals and product usability."
    />
    <meta content="David Alberto Adler" property="og:site_name" />
    <meta
      content="Experienced Full Stack Engineer, Founder and Contractor with a demonstrated history of working with startups and large enterprises. A blend of business and technical skills. Experience in leadership roles. Strongly attuned to business goals and product usability."
      property="og:description"
    />
    <meta content="David Alberto Adler" property="og:title" />
    <meta content="profile" property="og:type" />
    <meta
      content="https://davidadler.pages.dev/static/immutable/original/IMG_7983_open_graph.jpeg"
      property="og:image"
    />
    <meta content="David Alberto Adler" property="og:url" />
    <meta property="profile:first_name" content="David" />
    <meta property="profile:last_name" content="Adler" />
    <meta property="profile:gender" content="male" />

    <link
      rel="preload"
      href="/static/immutable/fonts/Virgil.woff2"
      as="font"
      type="font/woff2"
      crossorigin
    />
    <style>
      /* Label text color variable */
      :root {
        --label: #333;
        --labelSecondary: rgba(60, 60, 67, 0.6);
        --labelTertiary: rgba(60, 60, 67, 0.3);
        --background: white;

        /* ngl stolen from GitHub */
        --btn-primary-text: #ffffff;
        --btn-primary-bg: #1f883d;
        --btn-primary-border: rgba(31, 35, 40, 0.15);
        --btn-primary-shadow: 0 1px 0 rgba(31, 35, 40, 0.1);
        --btn-primary-inset-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.03);
        --btn-primary-hover-bg: #1a7f37;
        --btn-primary-hover-border: rgba(31, 35, 40, 0.15);
        --btn-primary-selected-bg: hsla(137, 66%, 28%, 1);
        --btn-primary-selected-shadow: inset 0 1px 0 rgba(0, 45, 17, 0.2);
      }

      /* Dark mode */
      @media (prefers-color-scheme: dark) {
        :root {
          --label: white;
          --labelSecondary: rgba(235, 235, 245, 0.6);
          --labelTertiary: rgba(235, 235, 245, 0.3);
          --background: rgb(36, 36, 36);

          --btn-primary-bg: #238636;
          --btn-primary-border: rgba(240, 246, 252, 0.1);
          --btn-primary-shadow: 0 0 transparent;
          --btn-primary-inset-shadow: 0 0 transparent;
          --btn-primary-hover-bg: #2ea043;
          --btn-primary-hover-border: rgba(240, 246, 252, 0.1);
          --btn-primary-selected-bg: #238636;
          --btn-primary-selected-shadow: 0 0 transparent;
        }
      }

      @font-face {
        font-family: 'Virgil';
        src: url('/static/immutable/fonts/Virgil.woff2');
        font-display: fallback;
      }
      *,
      *:before,
      *:after {
        box-sizing: border-box;
      }
      * {
        font-family: 'Virgil';
        color: var(--label);
        user-select: none;
      }
      html,
      body {
        background: var(--background);
        margin: 0;
        padding: 0;
      }

      a {
        text-decoration: none;
        padding: 0px 16px 4px 16px;
        margin-bottom: 12px;
      }
      a:hover {
        border-bottom: 1px solid var(--label);
      }

      @media (max-height: 789px) {
        #copyright {
          display: none;
        }
      }

      .btn.primary {
        cursor: pointer;
        background-color: var(--btn-primary-bg);
        border: solid var(--btn-primary-border);
        border-radius: 8px;
        padding: 8px 16px;
        font-family: sans-serif;
        color: var(--btn-primary-text);
        box-shadow: var(--btn-primary-shadow);
        transition: background-color 0.2s ease-in-out,
          border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        transition: transform 0.8s ease-in-out;
      }

      .btn.primary:hover {
        background-color: var(--btn-primary-hover-bg);
        border-color: var(--btn-primary-hover-border);
      }

      .btn.primary:active {
        background-color: var(--btn-primary-selected-bg);
        border-color: var(--btn-primary-selected-border);
        box-shadow: var(--btn-primary-selected-shadow);
      }

      @keyframes btn-primary-border-pulsate {
        0% {
          border-color: var(--btn-primary-hover-border);
        }
        50% {
          border-color: var(--btn-primary-selected-border);
        }
        100% {
          border-color: var(--btn-primary-hover-border);
        }
      }
    </style>
  </head>
  <body>
    <canvas
      id="canvas"
      style="
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        margin: auto;
        pointer-events: none;
      "
    ></canvas>
    <div
      style="
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        width: 100vw;
        /* This removes horizontal scroll caused on Windows by scrollbars as yet not tested https://stackoverflow.com/a/23367686/1376627 */
        max-width: 100%;
        min-height: 80vh;
      "
    >
      <h1 style="text-align: center; font-size: 48px; line-height: 61px">
        David Alberto Adler
      </h1>
      <div
        style="
          overflow: hidden;
          position: relative;
          background-color: rgb(242, 235, 240);
          border: solid var(--label);
          border-color: var(--label);
          border-width: 3px 4px 3px 5px;
          border-radius: 95% 4% 92% 5%/4% 95% 6% 95%;
          transform: rotate(2deg);
        "
      >
        <div
          style="
            position: absolute;
            z-index: 2;
            left: 0;
            right: 0;
            margin: auto;
            transform: rotate(358deg);
            display: flex;
            justify-content: center;
          "
        >
          <button id="call" class="btn primary" style="transform: scale(0)">
            Call David Now
          </button>
        </div>
        <img
          src="/static/immutable/webp/0E9A9020.webp"
          alt="David Adler Face Eyes Follow Mouse"
          id="image"
          width="500"
        />
      </div>

      <!-- Links -->
      <div
        style="
          display: flex;
          margin-top: 20px;
          font-size: 24px;
          width: 100%;
          max-width: 1000px;
          justify-content: space-between;
          padding: 20px;
          flex-wrap: wrap;
          justify-content: center;
        "
      >
        <!-- CV -->
        <a href="/cv.pdf" target="_blank">CV</a>
        <!-- GitHub -->
        <a href="https://github.com/mfbx9da4" target="_blank">GitHub</a>
        <!-- LinkedIn -->
        <a
          href="https://www.linkedin.com/in/david-adler-71056671/"
          target="_blank"
          >LinkedIn</a
        >
        <!-- StackOverflow -->
        <a
          href="https://stackoverflow.com/users/1376627/david-adler"
          target="_blank"
          >StackOverflow</a
        >
        <!-- Twitter -->
        <a href="https://twitter.com/da_adler" target="_blank">Twitter</a>

        <!-- Instagram -->
        <a href="https://www.instagram.com/davidadlerfb/" target="_blank"
          >Instagram</a
        >

        <!-- Hacker News -->
        <a href="https://news.ycombinator.com/user?id=mfbx9da4" target="_blank"
          >Hacker News</a
        >
      </div>
    </div>
    <!-- Positioned in the bottom right hand corner label tertiary -->
    <div
      id="copyright"
      style="
        position: fixed;
        bottom: 0;
        right: 0;
        padding: 10px;
        font-size: 12px;
        color: var(--labelSecondary);
        cursor: pointer;
      "
    ></div>
    <script>
      const h1 = document.querySelector('h1')
      if (!h1) throw new Error('Missing h1')
      // Shorten the name for mobile
      if (window.innerWidth < 700) h1.innerText = 'David Adler'
      const callButton = document.getElementById('call')
      if (!callButton) throw new Error('Missing call button')

      const copyright = document.getElementById('copyright')
      copyright.innerHTML = 'Â© ' + new Date().getFullYear() + ' David Adler'
      copyright.onclick = () =>
        alert(
          `I only put this here so you have a handy way of knowing the current year is ${new Date().getFullYear()}. You hereby have my permission to come back at any time to check what year it is.`
        )

      const directionVectors = {
        north: { x: 0, y: -1 },
        'north north east': { x: 0.25, y: -0.75 },
        'north east': { x: 0.5, y: -0.5 },
        'north east east': { x: 0.75, y: -0.25 },
        east: { x: 1, y: 0 },
        'south east east': { x: 0.75, y: 0.25 },
        'south east': { x: 0.5, y: 0.5 },
        'south south east': { x: 0.25, y: 0.75 },
        south: { x: 0, y: 1 },
        'south south west': { x: -0.25, y: 0.75 },
        'south west': { x: -0.5, y: 0.5 },
        'south west west': { x: -0.75, y: 0.25 },
        west: { x: -1, y: 0 },
        'north west west': { x: -0.75, y: -0.25 },
        'north west': { x: -0.5, y: -0.5 },
        'north north west': { x: -0.25, y: -0.75 },
      }

      const rawPhotos = [
        {
          url: '/static/immutable/webp/0E9A9000.webp',
          // The direction the photo is pointing
          direction: 'north',
          // The coordinates of the eyes, these are used for aligning the photos so
          // the eyes are in the center of the screen
          leftEye: {
            x: 221.21,
            y: 248.62,
          },
          rightEye: {
            x: 306.64,
            y: 247.35,
          },
        },
        {
          url: '/static/immutable/webp/0E9A9002.webp',
          direction: 'north east',
          leftEye: {
            x: 223.12,
            y: 250.54,
          },
          rightEye: {
            x: 309.19,
            y: 249.26,
          },
        },
        {
          url: '/static/immutable/webp/0E9A9003.webp',
          direction: 'north east east',
          leftEye: {
            x: 236.51,
            y: 251.17,
          },
          rightEye: {
            x: 323.21,
            y: 249.9,
          },
        },
        {
          url: '/static/immutable/webp/0E9A9004.webp',
          direction: 'east',
          leftEye: {
            x: 236.51,
            y: 257.55,
          },
          rightEye: {
            x: 323.21,
            y: 255,
          },
        },
        {
          url: '/static/immutable/webp/0E9A9005.webp',
          direction: 'south east east',
          leftEye: {
            x: 240.97,
            y: 256.91,
          },
          rightEye: {
            x: 328.31,
            y: 255,
          },
        },
        {
          url: '/static/immutable/webp/0E9A9006.webp',
          direction: 'south east',
          leftEye: {
            x: 231.41,
            y: 256.27,
          },
          rightEye: {
            x: 320.02,
            y: 250.54,
          },
        },
        {
          url: '/static/immutable/webp/0E9A9008.webp',
          direction: 'south south east',
          leftEye: {
            x: 233.32,
            y: 258.82,
          },
          rightEye: {
            x: 320.66,
            y: 256.27,
          },
        },
        {
          url: '/static/immutable/webp/0E9A9009.webp',
          direction: 'south',
          leftEye: {
            x: 235.87,
            y: 255.64,
          },
          rightEye: {
            x: 328.31,
            y: 252.45,
          },
        },
        {
          url: '/static/immutable/webp/0E9A9012.webp',
          direction: 'south south west',
          leftEye: {
            x: 211.65,
            y: 260.1,
          },
          rightEye: {
            x: 302.81,
            y: 257.55,
          },
        },
        {
          url: '/static/immutable/webp/0E9A9013.webp',
          direction: 'south west',
          leftEye: {
            x: 214.2,
            y: 256.27,
          },
          rightEye: {
            x: 306.64,
            y: 255,
          },
        },
        {
          url: '/static/immutable/webp/0E9A9015.webp',
          direction: 'south west west',
          leftEye: {
            x: 208.46,
            y: 251.17,
          },
          rightEye: {
            x: 303.45,
            y: 249.9,
          },
        },
        {
          url: '/static/immutable/webp/0E9A9017.webp',
          direction: 'west',
          leftEye: {
            x: 201.45,
            y: 252.45,
          },
          rightEye: {
            x: 291.34,
            y: 248.62,
          },
        },
        {
          url: '/static/immutable/webp/0E9A9020.webp',
          direction: 'north west',
          leftEye: {
            x: 197.62,
            y: 255,
          },
          rightEye: {
            x: 290.06,
            y: 249.26,
          },
        },
        {
          url: '/static/immutable/webp/0E9A9019.webp',
          direction: 'north north west',
          leftEye: {
            x: 207.82,
            y: 246.07,
          },
          rightEye: {
            x: 302.17,
            y: 240.34,
          },
        },
      ]

      const hoveredPhoto = {
        url: '/static/immutable/webp/0E9A8952_hovered.webp',
        direction: 'north',
        leftEye: {
          x: 207.83,
          y: 249.9,
        },
        rightEye: {
          x: 297.71,
          y: 246.08,
        },
      }
      const clickedPhoto = {
        url: '/static/immutable/webp/0E9A8956_clicked.webp',
        direction: 'north east',
        leftEye: {
          x: 203.36,
          y: 260.1,
        },
        rightEye: {
          x: 297.71,
          y: 260.74,
        },
      }
      const balloonPhotoUrl = '/static/immutable/resized/IMG_7981.png'

      // Each photo points in a direction convert these human readable directions into vectors
      const photosWithVectors = rawPhotos.map((photo) => {
        const vector = directionVectors[photo.direction]
        if (!vector) {
          throw new Error(`Unknown direction ${photo.direction}`)
        }
        return { ...photo, vector }
      })

      // Convert each direction vector into two vectors indicating the section
      // of the screen it captures flush against it's neighbouring photos
      const photos = photosWithVectors.map((photo, index) => {
        // Indexes wrap around
        const antiClockwise =
          photosWithVectors[
            (index - 1 + photosWithVectors.length) % photosWithVectors.length
          ]
        const clockwise =
          photosWithVectors[(index + 1) % photosWithVectors.length]
        if (!antiClockwise || !clockwise) {
          throw new Error(`Missing neighbour for photo ${photo.url}`)
        }
        const midpointAnticlockwise = {
          x: (photo.vector.x + antiClockwise.vector.x) / 2,
          y: (photo.vector.y + antiClockwise.vector.y) / 2,
        }
        const midpointClockwise = {
          x: (photo.vector.x + clockwise.vector.x) / 2,
          y: (photo.vector.y + clockwise.vector.y) / 2,
        }
        return {
          ...photo,
          section: [midpointAnticlockwise, midpointClockwise],
        }
      })

      // The width of the frame of the photo
      const frameWidth = Math.min(460, window.innerWidth - 100)
      // The width of the photo inside the frame must be bigger as it will need to be offset to align eyes
      const scaledPhotoWidth = frameWidth + 40
      const frameHeight = frameWidth * 1.2
      const image = document.getElementById('image')
      if (!image) {
        throw new Error('Missing image')
      }
      // Don't show a dialog to download the image on iPhone long press
      image.oncontextmenu = (e) => e.preventDefault()
      const frame = image.parentElement
      if (!frame) {
        throw new Error('Missing frame')
      }

      frame.style.width = `${frameWidth}px`
      frame.style.height = `${frameHeight}px`

      // Preload all images after the first one has loaded
      const preloadImage = (url) =>
        new Promise((resolve, reject) => {
          const img = new Image()
          img.onload = () => resolve()
          img.onerror = (e) => reject(e)
          img.src = url
        })
      let hasLoadedAllImages = false
      image.onload = async () => {
        if (hasLoadedAllImages) return
        hasLoadedAllImages = true

        await Promise.all(
          photos.concat([hoveredPhoto, clickedPhoto]).map(async (photo) => {
            try {
              await preloadImage(photo.url)
              photo.imageLoaded = true
            } catch (e) {
              // Ignore
            }
          })
        )
        await preloadImage(balloonPhotoUrl)
      }
      if (image.complete) {
        image.onload()
      }

      const eyesRelativePosition = { x: frameWidth / 2, y: frameWidth / 2 }

      let eyesAbsolutePosition = null
      function getEyesAbsolutePosition() {
        if (!eyesAbsolutePosition) {
          // Avoid layout thrashing
          const frameRect = frame.getBoundingClientRect()
          eyesAbsolutePosition = {
            x: frameRect.left + eyesRelativePosition.x,
            y: frameRect.top + eyesRelativePosition.y,
          }
        }
        return eyesAbsolutePosition
      }

      function distance(point1, point2) {
        const x = point1.x - point2.x
        const y = point1.y - point2.y
        return Math.sqrt(x * x + y * y)
      }

      function isInCentralPortionOfFace(x, y) {
        const frameAbsoluteCenter = getEyesAbsolutePosition()
        return distance({ x, y }, frameAbsoluteCenter) < 60
      }

      let lastTimeEnteredFace = 0
      let timeoutIdHoveredFace = 0

      /** @param {MouseEvent | TouchEvent} e */
      function handleMouseMove(e) {
        // get touch or mouse position
        const x = 'clientX' in e ? e.clientX : e.touches[0].clientX
        const y = 'clientY' in e ? e.clientY : e.touches[0].clientY

        const frameAbsoluteCenter = getEyesAbsolutePosition()

        // Get unit vector from center of frame to mouse
        const vector = {
          // x should be from -1 to 1
          x: (x - frameAbsoluteCenter.x) / frameAbsoluteCenter.x,
          // y should be from -1 to 1
          y: (y - frameAbsoluteCenter.y) / frameAbsoluteCenter.y,
        }

        // The vector will be inside one of the sections of the photos, find which one
        let closestPhoto = photos.find((closest, photo) => {
          const [lower, upper] = closest.section
          // https://stackoverflow.com/a/17497339/1376627
          // if (AxB * AxC >= 0 && CxB * CxA >= 0)
          // then B is definitely inside A and C
          const lowerInside = vector.x * lower.y - vector.y * lower.x <= 0
          const upperInside = vector.x * upper.y - vector.y * upper.x >= 0
          return lowerInside && upperInside
        })

        // Delay showing the hovered face to avoid jank during quick swipes
        if (isInCentralPortionOfFace(x, y)) {
          if (lastTimeEnteredFace === 0) {
            lastTimeEnteredFace = Date.now()
            timeoutIdHoveredFace = setTimeout(() => handleMouseMove(e), 150)
          } else if (Date.now() - lastTimeEnteredFace > 150) {
            closestPhoto = hoveredPhoto
          }
        } else {
          lastTimeEnteredFace = 0
          clearTimeout(timeoutIdHoveredFace)
        }

        if (!closestPhoto) {
          throw new Error('Missing closest photo')
        }

        // set image to closest photo
        image.width = scaledPhotoWidth
        // This is a hardcoded value all the photos have this width
        const naturalWidth = 510
        // We want to align the center of the eyes to the center of the frame
        const ratio = scaledPhotoWidth / naturalWidth
        const naturalRightEyeCoords = closestPhoto.rightEye
        const naturalLeftEyeCoords = closestPhoto.leftEye
        const naturalCenter = {
          x: (naturalRightEyeCoords.x + naturalLeftEyeCoords.x) / 2,
          y: (naturalRightEyeCoords.y + naturalLeftEyeCoords.y) / 2,
        }
        // Now that we have the natural center we need to scale it down to the target size
        const scaledCenter = {
          x: naturalCenter.x * ratio,
          y: naturalCenter.y * ratio,
        }

        // Now we can work out the offset we need to apply to the image to align the eyes
        const offset = {
          x: eyesRelativePosition.x - scaledCenter.x,
          y: eyesRelativePosition.y - scaledCenter.y,
        }

        image.src = closestPhoto.url
        // Avoid shifting the image before it's loaded as otherwise it will shift the eyes of the old image
        image.onload = () => {
          image.style.transform = `translate(${offset.x}px, ${offset.y}px)`
        }
        if (image.complete) {
          image.onload()
        }
      }

      function handleOnResize() {
        // Clear the cached eyes absolute center
        eyesAbsolutePosition = null

        // If the last href and the h1 are all in the viewport then we can block scrolling
        // to make for a better experience on mobile
        const lastHref = document.querySelector('a:last-of-type')
        if (!lastHref || !h1) {
          console.warn('Missing last href or h1')
        }
        const lastHrefRect = lastHref.getBoundingClientRect()
        const h1Rect = h1.getBoundingClientRect()
        const lastHrefInViewport =
          lastHrefRect.top >= 0 &&
          lastHrefRect.left >= 0 &&
          lastHrefRect.bottom <= window.innerHeight &&
          lastHrefRect.right <= window.innerWidth
        const h1InViewport =
          h1Rect.top >= 0 &&
          h1Rect.left >= 0 &&
          h1Rect.bottom <= window.innerHeight &&
          h1Rect.right <= window.innerWidth
        if (lastHrefInViewport && h1InViewport) {
          document.body.style.overflow = 'hidden'
        } else {
          document.body.style.overflow = 'auto'
        }
      }

      let clicks = 0

      /** @param {MouseEvent} e */
      function handleClick(e) {
        // If we click and we're in the central portion of the face then show the clicked photo
        const x = e.clientX
        const y = e.clientY
        if (isInCentralPortionOfFace(x, y)) {
          image.src = clickedPhoto.url
          performBalloonAnimation()

          if (++clicks >= 2) {
            callButton.parentElement.style.marginTop = frameHeight / 28 + 'px'
            callButton.style.transform = 'scale(1)'
            callButton.onclick = () => {
              callButton.style.animation =
                'btn-primary-border-pulsate 2.5s infinite'
              callDavid(() => {
                callButton.style.animation = ''
                callButton.style.transform = 'scale(0)'
                callButton.innerText = 'Call David Now'
              })
            }
          }
        }
      }

      window.addEventListener('click', handleClick)
      window.addEventListener('mousemove', handleMouseMove)
      window.addEventListener('touchstart', handleMouseMove)
      window.addEventListener('touchmove', handleMouseMove)
      window.addEventListener('resize', handleOnResize)

      // Fake a mouse move to the north west of the screen to start
      handleMouseMove({ clientX: 0, clientY: 0 })
      // Fake a resize to start
      handleOnResize()

      // #region Call David
      let isCalling = false
      function callDavid(done) {
        if (isCalling) return
        isCalling = true
        const ringtone = new Audio()
        ringtone.src = '/static/immutable/audio/compressed/ringing.mp3'
        ringtone.loop = true
        const response = new Audio()
        response.src = '/static/immutable/audio/compressed/response.mp3'
        callButton.innerText = 'Calling...'
        setTimeout(() => {
          ringtone.play()

          setTimeout(() => {
            ringtone.pause()
            callButton.innerText = 'Connected'
            response.onended = () => {
              isCalling = false
              done()
            }
            response.play()
          }, 7000)
        }, 500)
      }

      // #region Balloon Animation
      class Balloon {
        constructor(options) {
          this.canvas = options.canvas
          this.ctx = options.ctx
          this.image = options.image
          this.width = options.width
          this.height = options.height
          this.x = options.x
          this.y = options.y
          this.vx = options.vx
          this.vy = options.vy
          this.ax = options.ax
          this.ay = options.ay
          this.friction = options.friction
          this.sway = Math.random() * 1.5
        }

        draw() {
          this._update()
          this.ctx.drawImage(
            this.image,
            this.x,
            this.y,
            this.width,
            this.height
          )
        }

        _update() {
          this.vx += this.ax
          this.vy += this.ay
          this.vx *= this.friction
          this.vy *= this.friction
          this.x += this.vx
          // Apparently rounding improves performance as it prevents anti-aliasing computation
          this.y -= Math.round(this.vy)
          this.x += Math.round(Math.sin(Date.now() * 0.001) * this.sway)
        }
      }

      let isBalloonAnimationRunning = false
      let balloons = []
      // Optimization for drawing more efficiently
      const offScreenCanvas = document.createElement('canvas')
      function performBalloonAnimation() {
        const image = new Image()
        image.src = balloonPhotoUrl
        const naturalWidth = 250
        const naturalHeight = 350
        const imageRatio = naturalHeight / naturalWidth
        const canvas = document.getElementById('canvas')
        const ctx = canvas.getContext('2d')
        canvas.width = window.innerWidth
        canvas.height = window.innerHeight
        offScreenCanvas.width = canvas.width
        offScreenCanvas.height = canvas.height
        const offScreenCtx = offScreenCanvas.getContext('2d')
        const numberOfBalloons = Math.round(window.innerWidth / 50)
        for (let i = 0; i < numberOfBalloons; i++) {
          // Optimization: integers are more performant
          const width = Math.round(Math.random() * 50 + 50)
          const height = Math.round(width * imageRatio)
          balloons.push(
            new Balloon({
              canvas: offScreenCanvas,
              ctx: offScreenCtx,
              image,
              width,
              height,
              x: Math.random() * window.innerWidth - width / 2,
              y: window.innerHeight,
              vx: Math.random() * 12 - 6,
              vy: 1 + Math.random() * 10,
              ax: 0,
              ay: 0.15 + Math.random() * 0.14,
              friction: 0.98,
            })
          )
        }
        const animationLoop = () => {
          offScreenCtx.clearRect(0, 0, canvas.width, canvas.height)
          const isAboveScreen = (x) => x.y + x.height < 0
          balloons = balloons.filter((x) => !isAboveScreen(x))
          balloons.forEach((x) => x.draw())
          // Optimization: Faster to redraw everything on an offscreen canvas
          // and then redraw once on the actual canvas
          ctx.clearRect(0, 0, canvas.width, canvas.height)
          ctx.drawImage(offScreenCanvas, 0, 0)
          if (balloons.length) {
            requestAnimationFrame(animationLoop)
          } else {
            isBalloonAnimationRunning = false
          }
        }
        if (!isBalloonAnimationRunning) {
          isBalloonAnimationRunning = true
          animationLoop()
        }
      }
      // #endregion
    </script>

    <!-- Cloudflare Web Analytics -->
    <script
      defer
      src="https://static.cloudflareinsights.com/beacon.min.js"
      data-cf-beacon='{"token": "faf9c306bd1c4e6983fe6b90dbdf01b1"}'
    ></script>
    <!-- End Cloudflare Web Analytics -->
  </body>
</html>
